//
//  MYKeychain.h
//  MYCrypto
//
//  Created by Jens Alfke on 3/23/09.
//  Copyright 2009 Jens Alfke. All rights reserved.
//

#import <Foundation/Foundation.h>
@class MYSymmetricKey, MYPublicKey, MYKeyPair, MYCertificate, MYSHA1Digest;


/** A Keychain, a secure database of cryptographic keys.
    This class wraps the Security framework's SecKeychain API. */
@interface MYKeychain : NSObject 
{
#if !TARGET_OS_IPHONE || TARGET_IPHONE_SIMULATOR
    SecKeychainRef _keychain;
#endif
}

/** Returns a MYKeychain instance representing the user's default keychain.
    This is the instance you'll usually want to add keys to. */
+ (MYKeychain*) defaultKeychain;

/** Returns a MYKeychain instance representing the aggregate of all open keychains.
    This is the instance you'll usually want to search for keys with. */
+ (MYKeychain*) allKeychains;

#pragma mark SYMMETRIC KEYS:

- (MYSymmetricKey*) generateSymmetricKeyOfSize: (unsigned)keySizeInBits
                                     algorithm: (uint32_t/*CCAlgorithm*/)algorithm;
- (NSEnumerator*) enumerateSymmetricKeys;
- (NSEnumerator*) symmetricKeysWithAlias: (NSString*)alias;

/** Enumerates all symmetric keys in the keychain. */
- (NSEnumerator*) enumerateSymmetricKeys;

#pragma mark PUBLIC KEYS:

/** Looks up an existing public key with the given digest.
    Returns nil if there is no such key in the keychain.
    (This method does not look for keys embedded in certificates, only 'bare' keys.) */
- (MYPublicKey*) publicKeyWithDigest: (MYSHA1Digest*)pubKeyDigest;

/** Enumerates all public keys in the keychain.
    (This method does not find keys embedded in certificates, only 'bare' keys.) */
- (NSEnumerator*) enumeratePublicKeys;

/** Imports a public key into the keychain, given its external representation
    (as generated by -[MYPublicKey exportDataInFormat:withPEM:].) */
- (MYPublicKey*) importPublicKey: (NSData*)keyData;

#pragma mark CERTIFICATES:

/** Looks up an existing certificate with the given public-key digest.
    Returns nil if there is no such certificate in the keychain. */
- (MYCertificate*) certificateWithDigest: (MYSHA1Digest*)pubKeyDigest;

/** Enumerates all certificates in the keychain. */
- (NSEnumerator*) enumerateCertificates;

/** Imports a certificate into the keychain, given its external representation. */
- (MYCertificate*) importCertificate: (NSData*)data;

#pragma mark KEY-PAIRS:

/** Looks up an existing key-pair whose public key has the given digest.
    Returns nil if there is no such key-pair in the keychain.
    (This method does not look for keys embedded in certificates, only 'bare' keys.) */
- (MYKeyPair*) keyPairWithDigest: (MYSHA1Digest*)pubKeyDigest;

/** Enumerates all key-pairs in the keychain.
    (This method does not find keys embedded in certificates, only 'bare' keys.) */
- (NSEnumerator*) enumerateKeyPairs;

/** Generates a new RSA key-pair and adds both keys to the keychain.
    This is very slow -- it may take several seconds, depending on the key size, CPU speed,
    and other random factors. You should probably show some kind of progress indicator before
    calling this method, so the user doesn't think the app has locked up!
    @param keySize  The RSA key length in bits. Must be a power of two. Longer keys are harder
        to break, but operate more slowly and generate larger signatures.
        2048 is a good default choice. You could use 1024 if the data and signatures won't need
        to stay secure for years; or you could use 4096 if you're extremely paranoid. */
- (MYKeyPair*) generateRSAKeyPairOfSize: (unsigned)keySize;

@end




#pragma mark -
#pragma mark METHODS NOT SUPPORTED ON IPHONE:


#if !TARGET_OS_IPHONE

@interface MYKeychain (MacOnly)

/** Creates a MYKeychain for an existing SecKeychainRef. */
- (id) initWithKeychainRef: (SecKeychainRef)keychainRef;

/** Opens a keychain file. */
+ (MYKeychain*) openKeychainAtPath: (NSString*)path;

/** Creates a new keychain file. */
+ (MYKeychain*) createKeychainAtPath: (NSString*)path
                        withPassword: (NSString*)password;

/** Closes and deletes the keychain's file. You should not use this object any more. */
- (BOOL) deleteKeychainFile;

/** Returns the underlying SecKeychainRef for this keychain.
    This will be NULL for the special allKeychains instance, because it doesn't
    represent a single specific keychain. To handle that case, use the
    keychainRefOrDefault property instead. */
@property (readonly) SecKeychainRef keychainRef;

/** Returns the underlying SecKeychainRef for this keychain.
    The special allKeychains instance returns a reference to the default keychain,
    as a convenience. */
@property (readonly) SecKeychainRef keychainRefOrDefault;

/** The path of this keychain's file. */
@property (readonly) NSString* path;

/** The underlying CSSM storage handle; used when calling CSSM APIs. */
@property (readonly) CSSM_CSP_HANDLE CSPHandle;


/** Enumerates all public keys in the keychain that have the given alias string. */
- (NSEnumerator*) symmetricKeysWithAlias: (NSString*)alias;

/** Enumerates all public keys in the keychain that have the given alias string. */
- (NSEnumerator*) publicKeysWithAlias: (NSString*)alias;


/** Imports a certificate into the keychain, given its external representation. */
- (MYCertificate*) importCertificate: (NSData*)data
                                type: (CSSM_CERT_TYPE) type
                            encoding: (CSSM_CERT_ENCODING) encoding;

/** Imports a key-pair into the keychain, given the external representations
    of both the public and private keys.
    Since the private key data is encrypted, the Security agent will prompt the user to enter
    the passphrase. */
- (MYKeyPair*) importPublicKey: (NSData*)pubKeyData 
                    privateKey: (NSData*)privKeyData;

/** Imports a key-pair into the keychain, given the external representations
    of both the public and private keys.
    Since the private key data is encrypted, the Security agent will prompt the user to enter
    the passphrase. You can specify the title and prompt message for this alert panel. */
- (MYKeyPair*) importPublicKey: (NSData*)pubKeyData 
                    privateKey: (NSData*)privKeyData
                    alertTitle: (NSString*)title
                   alertPrompt: (NSString*)prompt;

@end

#endif
