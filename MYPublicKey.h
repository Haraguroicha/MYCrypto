//
//  MYPublicKey.h
//  MYCrypto
//
//  Created by Jens Alfke on 3/25/09.
//  Copyright 2009 Jens Alfke. All rights reserved.
//

#import "MYKey.h"
@class MYSHA1Digest;

#if !TARGET_OS_IPHONE
#import <Security/SecKey.h>
#endif


/** Error domain for CSSM (low-level crypto) errors */
extern NSString* const MYCSSMErrorDomain;


/** A public key, which can be used for encrypting data and verifying signatures. */
@interface MYPublicKey : MYKey <MYEncryption>
{
    MYSHA1Digest *_digest;
}

/** The public key's SHA-1 digest. This is a convenient short (20-byte) identifier for the key. */
@property (readonly) MYSHA1Digest *publicKeyDigest;

/** Returns the receiver as a MYPublicKey.
    If the receiver already is a MYPublicKey, this just returns self.
    If it's a MYKeyPair, it returns a new MYPublicKey containing just the public key. */
@property (readonly) MYPublicKey *asPublicKey;

/** Encrypts a short piece of data using this key, returning the raw encrypted result.
    RSA can encrypt only <i>short</i> pieces of data, smaller than the key size in bits; this
    method will fail and return nil if the data is too long.
    RSA encryption is also much slower than regular symmetric-key encryption, so the correct
    way to encrypt a large block of data using a public key is to first generate a random
    symmetric key, called the "session key" (using a Cryptor), encrypt that session key with the 
    public key, and then encrypt your data with the session key. Send the encrypted session key
    and the encrypted data. */
- (NSData*) encryptData: (NSData*)data;

/** Verifies the signature of a block of data. If the result is YES, you can be assured that
    the signature was generated from the data using this key's matching private key.
    If the result is NO, something is wrong: either the data or the signature was modified,
    or the signature was generated by a different private key. */
- (BOOL) verifySignature: (NSData*)signature ofData: (NSData*)data;
    
@end
